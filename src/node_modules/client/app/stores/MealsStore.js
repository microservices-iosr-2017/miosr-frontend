import alt from 'client/app/alt';
import moment from 'moment';

import MealsActions from 'client/app/actions/MealsActions';
import MealsSource from 'client/app/sources/MealsSource';
import NutrientsSource from 'client/app/sources/NutrientsSource';

function parseFloatOrZero(flStr) {
  const fl = parseFloat(flStr);
  if(!isNaN(fl)) {
    return fl;
  } else {
    return 0.0;
  }
}

/**
 * Stores meals for given date (initically current date is used).
 * Synchronization with server can be performed with fetchMeals action. It triggers state change.
 * Date can be altered using changeDate action. Changing date doesn't trigger state change, but it
 * it automatically triggers resynchronization, which in turn trigger state change.
 */
class MealsStore {
  constructor() {
    this.date = moment();
    this.meals = [];

    this._resetNutrientsData();

    this.bindListeners({
      handleFetch: MealsActions.FETCH_MEALS,
      handleFetchSucceess: MealsActions.FETCH_MEALS_SUCCESS,
      handleAdd: MealsActions.ADD_MEAL,
      handleAddSuccess: MealsActions.ADD_MEAL_SUCCESS,
      handleChangeDate: MealsActions.CHANGE_DATE,
      handleNutrientsFetchSuccess: MealsActions.FETCH_NUTRIENTS_SUCCESS,
      handleNutrientsFetchFailure: MealsActions.FETCH_NUTRIENTS_FAILURE,
      handleFetchAddNutrientsSuccess: MealsActions.FETCH_ADD_NUTRIENTS_SUCCESS,
      handleFetchAddNutrientsFailure: MealsActions.FETCH_ADD_NUTRIENTS_FAILURE,
    });

    this._flattenAndAddQuantities = this._flattenAndAddQuantities.bind(this);
  }

  _resetNutrientsData() {
    this.nutrientsInMeals = {};
    this.successfulNutrientsFetches = 0;
    this.failedNutrientFetches = 0;

    this.nutrientsTodayCumulative = null;
    this.nutrientsTodayCumulativeUnits = null;
    this.chartDataReady = false;
  }

  handleFetch() {
    MealsSource.fetch(this.date);
  }

  handleFetchSucceess(mealsList) {
    const todaysOnly = mealsList.filter(ml => this.date.isSame(ml.date, 'day'));
    this.setState({meals: todaysOnly});

    this._resetNutrientsData();

    todaysOnly.forEach(meal => {
      NutrientsSource.fetch(meal.ndbno)
        .then(({ndbno, nutrientsList}) => {
          MealsActions.fetchNutrientsSuccess(ndbno, nutrientsList);
        })
        .catch(e => {
          // access response via error.response
          MealsActions.fetchNutrientsFailure(e);
        });
    });
  }

  handleAdd({date, name, ndbno, quantity}) {
    MealsSource.create(date, name, ndbno, quantity);
  }

  handleAddSuccess(addedMeal) {
    const modifiedMealsList = this.meals.concat([addedMeal]);
    this.setState({meals: modifiedMealsList});

    NutrientsSource.fetch(addedMeal.ndbno)
      .then(({ndbno, nutrientsList}) => {
        MealsActions.fetchAddNutrientsSuccess(ndbno, nutrientsList);
      })
      .catch(e => {
        // access response via error.response
        MealsActions.fetchAddNutrientsFailure(e);
      });
  }

  handleChangeDate(newDate) {
    this.date = newDate;
    MealsActions.fetchMeals.defer();
  }

  handleNutrientsFetchSuccess({ndbno, nutrientsList}) {
    this.nutrientsInMeals[ndbno] = nutrientsList;
    this.successfulNutrientsFetches += 1;

    const allFetched = this.successfulNutrientsFetches + this.failedNutrientFetches;
    if(allFetched >= this.meals.length) {
      if(allFetched > this.meals.length) {
        console.log('Warning: fetched more nutrient info than meals!');
      }

      if(this.successfulNutrientsFetches > 0) {
        this._calculateChartsData();
      } else {
        console.log('All nutrient fetches failed, no charts to display');
      }
    }
  }

  handleFetchAddNutrientsSuccess({ndbno, nutrientsList}) {
    this.nutrientsInMeals[ndbno] = nutrientsList;
    this._calculateChartsData();
  }

  handleNutrientsFetchFailure() {
    this.failedNutrientFetches += 1;
  }

  handleFetchAddNutrientsFailure() {
    console.log('Fetch additional failed');
  }

  _flattenAndAddQuantities(meals, nutrientsInMeals) {
    const quantities = {};
    meals.forEach(({ndbno, quantity}) => quantities[ndbno] = quantity);

    const nutrientsWithQuantities = [];
    for(var prop in nutrientsInMeals) {
      if(nutrientsInMeals.hasOwnProperty(prop)) {
        const ndbno = prop;
        const nutrientList = nutrientsInMeals[ndbno];
        const quantity = parseFloatOrZero(quantities[ndbno]);

        nutrientList.forEach(nutrient => {
          const id = nutrient.nutrient_id;
          const value = parseFloatOrZero(nutrient.value);

          nutrientsWithQuantities.push({id, value: (value*quantity)/100.0, unit: nutrient.unit});
        })
      }
    }

    return nutrientsWithQuantities;
  }

  _calculateChartsData() {
    const nutrientsWithQuantities = this._flattenAndAddQuantities(this.meals, this.nutrientsInMeals);

    const cumulative = {};
    const units = {};

    nutrientsWithQuantities.forEach(({id, value, unit}) => {
      if(!cumulative.hasOwnProperty(id)) {
        cumulative[id] = value;
        units[id] = unit;
      } else {
        cumulative[id] += value;
      }
    });

    this.setState({nutrientsTodayCumulative: cumulative,
      nutrientsTodayCumulativeUnits: units,
      chartDataReady: true});
  }
}

export default alt.createStore(MealsStore, 'MealsStore');
