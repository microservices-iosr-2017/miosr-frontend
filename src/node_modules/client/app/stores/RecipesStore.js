import flow from 'lodash/fp/flow';
import clone from 'lodash/clone';
import assign from 'lodash/assign';
import values from 'lodash/values';
import set from 'lodash/fp/set';
import RecipesActions from 'actions/RecipesActions';
import RecipeActions from 'actions/RecipeActions';
import RecipeSource from 'sources/RecipeSource';
import alt from '../alt';

const updateRecipe = (list, updater) => flow(
  clone,
  updater
)(list);

class RecipesStore {
  static config = {
    getState(currentState) {
      return assign({}, currentState, {recipes: values(currentState.recipes)});
    }
  };

  constructor() {
    this.recipes = {};
    this.err = null;
    this.loading = false;

    this.bindListeners({
      handleFetchLists: RecipesActions.FETCH_RECIPES,
      handleFetchSuccess: RecipesActions.FETCH_SUCCESS,
      handleFetchFailure: RecipesActions.FETCH_FAILURE,
      handleSubmitSuccess: RecipeActions.SUBMIT_SUCCESS,
      handleRecipeSearch: RecipesActions.SEARCH_RECIPES,
    });

    this.exportPublicMethods({recipe: this.recipe.bind(this)});
  }

  recipe(id) {
    return this.recipes[id];
  }

  handleFetchLists() {
    if (!this.loading) {
      this.setState({loading: true});
      RecipeSource.fetch();
    }
  }

  handleRecipeSearch(query) {
    RecipeSource.search(query);
  }

  handleFetchSuccess({entities}) {
    this.setState({recipes: entities.recipes, err: null, loading: false});
  }

  handleFetchFailure(err) {
    this.setState({err, loading: false});
  }

  handleUpdateRecipe(recipeId, updater) {
    const recipe = this.recipe(recipeId);
    const newRecipe = updateRecipe(recipe, updater);
    this.setState({recipes: set(recipeId, newRecipe)(this.recipes)});
  }

  handleSubmitSuccess({result, entities}) {
    this.setState({recipes: set(result, entities.recipes[result])(this.recipes)});
  }
}

export default alt.createStore(RecipesStore, 'RecipesStore');
