import MockAdapter from 'axios-mock-adapter';
import {login, EX as authEx, __RewireAPI__ as authRewire} from 'client/sharedjs/auth';
import cookies from 'js-cookie';

const LOCAL_AUTH_URL = authRewire.__get__('LOCAL_AUTH_URL');
const USERID_COOKIE_NAME = authRewire.__get__('USERID_COOKIE_NAME');
const REDIRURL_COOKIE_NAME = authRewire.__get__('REDIRURL_COOKIE_NAME');

const credentials = {username: 'test', password: 'pass'};

function removeCookies() {
  cookies.remove('user');
  cookies.remove('redirUrl');
}

const axios = new MockAdapter(authRewire.__get__('axios'));

let promise = null;
function setupWithRespone(status, payload) {
  axios.reset();
  axios.onPost(LOCAL_AUTH_URL).reply(status, payload);
  promise = login(credentials.username, credentials.password);

  /* Mocha must wait for login to complete all asynchronous operations
   * however, we cannot just return 'promise', because if we are testing failure scenario
   * rejected promise will cause Mocha to fail the suite */
  return promise.catch(() => 'OK');
}


describe('auth', () => {
  after(() => {
    axios.restore();
  });

  context('http200', () => {
    const payload = {userId: '123', redirectUrl: '/redirect.html'};

    before(() => setupWithRespone(200, payload));

    after(() => removeCookies());

    it('should resolve', () => {
      return promise.should.be.fulfilled;
    });

    it('should be resolved with correct argument: ', () => {
      promise.should.eventually.have.property('userId');
      promise.should.eventually.have.property('redirectUrl');
    });

    context('when promise resolves', () => {
      it('user" cookie should be set', () => {
        expect(cookies.get(USERID_COOKIE_NAME))
          .to.be.equal(payload.userId);
      });

      it('"redirUrl" cookie should be set', () => {
        expect(cookies.get(REDIRURL_COOKIE_NAME))
          .to.be.equal(payload.redirectUrl);
      });
    });
  });

  context('http403', () => {
    before(() => setupWithRespone(403, {message: 'any message'}));

    it('should reject with correct error type', () => {
      return promise.should.be.rejected
        .and.eventually.have.property('name', authEx.INCORRECT_CREDENTIALS);
    });
  });

  context('http500', () => {
    before(() => setupWithRespone(500));

    it('should reject with correct error type', () => {
      return promise.should.be.rejected
        .and.eventually.have.property('name', authEx.UNKNOWN);
    });
  });

  context('http200 with malformed payload', () => {
    before(() => setupWithRespone(200, '{abc'));

    it('should reject with UNKNOWN error type', () => {
      return promise.should.be.rejected
        .and.eventually.have.property('name', authEx.UNKNOWN);
    });
  });
});
